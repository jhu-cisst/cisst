/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-    */
/* ex: set filetype=cpp softtabstop=4 shiftwidth=4 tabstop=4 cindent expandtab: */

/*
  $Id$

  Author(s):  Peter Kazanzides, Anton Deguet
  Created on: 2008-11-13

  (C) Copyright 2008-2010 Johns Hopkins University (JHU), All Rights Reserved.

--- begin cisst license - do not edit ---

This software is provided "as is" under an open source license, with
no warranty.  The complete license can be found in license.txt and
http://www.cisst.org/cisst/license.txt.

--- end cisst license ---
*/


#ifndef _mtsInterfaceRequired_h
#define _mtsInterfaceRequired_h

#include <cisstMultiTask/mtsInterfaceRequiredOrInput.h>

#include <cisstCommon/cmnNamedMap.h>

#include <cisstMultiTask/mtsCommandBase.h>
#include <cisstMultiTask/mtsCommandVoid.h>
#include <cisstMultiTask/mtsCommandWrite.h>
#include <cisstMultiTask/mtsCommandQueuedVoid.h>
#include <cisstMultiTask/mtsCommandQueuedWrite.h>
#include <cisstMultiTask/mtsFunctionVoid.h>
#include <cisstMultiTask/mtsFunctionQualifiedRead.h>


// Always include last
#include <cisstMultiTask/mtsExport.h>

/*!
  \file
  \brief Declaration of mtsInterfaceRequired
 */


/*!
  \ingroup cisstMultiTask

  This class implements the required interface for a component
  (mtsComponent, mtsTask, ...).  The required interface gets populated
  with pointers to command objects, which have four signatures:

     Void:           no parameters
     Read:           one non-const parameter
     Write:          one const parameter
     QualifiedRead:  one non-const (read) and one const (write) parameter

  The required interface may also have command object pointers for the
  following types of event handlers:

     Void:           no parameters
     Write:          one const parameter

  When the required interface of this component is connected to the
  provided interface of another component, the command object pointers
  are "bound" to command objects provided by the other component.
  Similarly, the event handlers are added as observers of events that
  are generated by the provided interface of the other component.

  This implementation is simpler than the provided interface because
  we assume that a required interface is never connected to more than
  one provided interface, whereas a provided interface can be used by
  multiple required interfaces.  While one can conceive of cases where
  it may be useful to have a required interface connect to multiple
  provided interfaces (e.g., running a robot simulation in parallel
  with a real robot), at this time it is not worth the trouble.
 */

class CISST_EXPORT mtsInterfaceRequired: public mtsInterfaceRequiredOrInput
{
    CMN_DECLARE_SERVICES(CMN_NO_DYNAMIC_CREATION, CMN_LOG_LOD_RUN_ERROR);

    friend class mtsComponentProxy;
    friend class mtsComponentInterfaceProxyClient;
    friend class mtsManagerLocal;
    friend class mtsManagerLocalTest;

protected:

    /*! Mailbox (if supported). */
    mtsMailBox * MailBox;

    /*! Default constructor. Does nothing, should not be used. */
    mtsInterfaceRequired(void) {}

 public:

    /*! Default size for queues of events */
    enum {DEFAULT_EVENT_QUEUE_LEN = 16};
    
    /*! Constructor. Sets the name, device pointer, and mailbox for queued events.

      \param interfaceName Name of required interface

      \param mbox Mailbox to use for queued events (for tasks); set to
                  0 for devices Could use a boolean (useMbox) for last
                  parameter or delete it completely, and decide
                  whether or not to allocate a mailbox based on
                  dynamic type of device.
    */
    mtsInterfaceRequired(const std::string & interfaceName, mtsMailBox * mailBox);

    /*! Default destructor. */
    virtual ~mtsInterfaceRequired();

    /*! Get the names of commands required by this interface. */
    //@{
    virtual std::vector<std::string> GetNamesOfFunctions(void) const;
    virtual std::vector<std::string> GetNamesOfFunctionsVoid(void) const;
    virtual std::vector<std::string> GetNamesOfFunctionsRead(void) const;
    virtual std::vector<std::string> GetNamesOfFunctionsWrite(void) const;
    virtual std::vector<std::string> GetNamesOfFunctionsQualifiedRead(void) const;
    //@}

    /*! Get the names of event handlers that exist in this interface */
    //@{
    virtual std::vector<std::string> GetNamesOfEventHandlersVoid(void) const;
    virtual std::vector<std::string> GetNamesOfEventHandlersWrite(void) const;
    //@}

    /*! Find an event handler based on its name. */
    //@{
    virtual mtsCommandVoidBase * GetEventHandlerVoid(const std::string & eventName) const;
    virtual mtsCommandWriteBase * GetEventHandlerWrite(const std::string & eventName) const;
    //@}

    inline bool CouldConnectTo(mtsInterfaceProvidedOrOutput * CMN_UNUSED(interfaceProvidedOrOutput)) {
        return true;
    }
    bool ConnectTo(mtsInterfaceProvidedOrOutput * interfaceProvidedOrOutput);
    bool Disconnect(void);

    /*!
      \todo update documentation
      Bind command and events.  This method needs to provide a user
      Id so that GetCommandVoid and GetCommandWrite (queued
      commands) know which mailbox to use.  The user Id is provided
      by the provided interface when calling AllocateResources. */
 private:
    bool BindCommandsAndEvents(void);
 public:

    void DisableAllEvents(void);

    void EnableAllEvents(void);

    /*! Process any queued events. */
    size_t ProcessMailBoxes(void);

    /*! Send a human readable description of the interface. */
    void ToStream(std::ostream & outputStream) const;

protected:
 public: // adeguet1 todo fix -- this has been added for ostream << operator
#ifndef SWIG  // SWIG cannot deal with this
    class FunctionInfo
    {
        // For GCM UI
        friend class mtsManagerLocal;
        friend class mtsInterfaceRequired;
    protected:
        mtsFunctionBase * FunctionPointer;
        bool IsRequired;
    public:
        FunctionInfo(mtsFunctionBase & function, bool isRequired):
            FunctionPointer(&function),
            IsRequired(isRequired)
        {}

        ~FunctionInfo() {}

        inline void Detach(void) {
            FunctionPointer->Detach();
            FunctionPointer = 0;
        }

        void ToStream(std::ostream & outputStream) const
        {
            outputStream << *FunctionPointer;
            if (!IsRequired) {
                outputStream << " (optional)";
            } else {
                outputStream << " (required)";
            }
        }
    };

#endif // !SWIG
 protected:

    /*! Utility method to determine if an event handler should be
      queued or not based on the default policy for the interface and
      the user's requested policy.  This method also generates a
      warning or error in the log if needed. */
    bool UseQueueBasedOnInterfacePolicy(mtsEventQueuingPolicy queuingPolicy,
                                        const std::string & methodName,
                                        const std::string & eventName);

    typedef cmnNamedMap<FunctionInfo> FunctionInfoMapType;

    /*! Typedef for a map of name of zero argument command and name of command. */
    FunctionInfoMapType FunctionsVoid; // Void (command)

    /*! Typedef for a map of name of one argument command and name of command. */
    FunctionInfoMapType FunctionsRead; // Read (state read)

    /*! Typedef for a map of name of one argument command and name of command. */
    FunctionInfoMapType FunctionsWrite; // Write (command)

    /*! Typedef for a map of name of two argument command and name of command. */
    FunctionInfoMapType FunctionsQualifiedRead; // Qualified Read (conversion, read at time index, ...)

    /*! Typedef for a map of event name and event handler (command object). */
    typedef cmnNamedMap<mtsCommandVoidBase> EventHandlerVoidMapType;
    typedef cmnNamedMap<mtsCommandWriteBase> EventHandlerWriteMapType;
    EventHandlerVoidMapType EventHandlersVoid;
    EventHandlerWriteMapType EventHandlersWrite;

public:

    bool AddFunction(const std::string & functionName, mtsFunctionVoid & function, bool required = true);

    bool AddFunction(const std::string & functionName, mtsFunctionRead & function, bool required = true);

    bool AddFunction(const std::string & functionName, mtsFunctionWrite & function, bool required = true);

    bool AddFunction(const std::string & functionName, mtsFunctionQualifiedRead & function, bool required = true);

    template <class __classType>
    inline mtsCommandVoidBase * AddEventHandlerVoid(void (__classType::*method)(void),
                                                    __classType * classInstantiation,
                                                    const std::string & eventName,
                                                    mtsEventQueuingPolicy queuingPolicy = MTS_INTERFACE_EVENT_POLICY);

    inline mtsCommandVoidBase * AddEventHandlerVoid(void (*function)(void),
                                                    const std::string & eventName,
                                                    mtsEventQueuingPolicy = MTS_INTERFACE_EVENT_POLICY);

    template <class __classType, class __argumentType>
    inline mtsCommandWriteBase * AddEventHandlerWrite(void (__classType::*method)(const __argumentType &),
                                                      __classType * classInstantiation,
                                                      const std::string & eventName,
                                                      mtsEventQueuingPolicy queuingPolicy = MTS_INTERFACE_EVENT_POLICY);

    // PK: Can we get rid of this?
    template <class __classType>
    inline mtsCommandWriteBase * AddEventHandlerWriteGeneric(void (__classType::*method)(const mtsGenericObject &),
                                                             __classType * classInstantiation,
                                                             const std::string & eventName,
                                                             mtsEventQueuingPolicy queuingPolicy = MTS_INTERFACE_EVENT_POLICY);
};


#ifndef SWIG
template <class __classType>
inline mtsCommandVoidBase * mtsInterfaceRequired::AddEventHandlerVoid(void (__classType::*method)(void),
                                                                      __classType * classInstantiation,
                                                                      const std::string & eventName,
                                                                      mtsEventQueuingPolicy queuingPolicy)
{
    bool queued = this->UseQueueBasedOnInterfacePolicy(queuingPolicy, "AddEventHandlerVoid", eventName);
    mtsCommandVoidBase * actualCommand = new mtsCommandVoidMethod<__classType>(method, classInstantiation, eventName);
    if (queued) {
        if (MailBox)
            EventHandlersVoid.AddItem(eventName, new mtsCommandQueuedVoid(MailBox, actualCommand));
        else
            CMN_LOG_CLASS_INIT_ERROR << "No mailbox for queued event handler void \"" << eventName << "\"" << std::endl;
    } else {
        EventHandlersVoid.AddItem(eventName, actualCommand);
    }
    return EventHandlersVoid.GetItem(eventName);
}


inline mtsCommandVoidBase * mtsInterfaceRequired::AddEventHandlerVoid(void (*function)(void),
                                                                      const std::string & eventName,
                                                                      mtsEventQueuingPolicy queuingPolicy)
{
    bool queued = this->UseQueueBasedOnInterfacePolicy(queuingPolicy, "AddEventHandlerVoid", eventName);
    mtsCommandVoidBase * actualCommand = new mtsCommandVoidFunction(function, eventName);
    if (queued) {
        if (MailBox)
            EventHandlersVoid.AddItem(eventName, new mtsCommandQueuedVoid(MailBox, actualCommand));
        else
            CMN_LOG_CLASS_INIT_ERROR << "No mailbox for queued event handler void (func) \"" << eventName << "\"" << std::endl;
    } else {
        EventHandlersVoid.AddItem(eventName, actualCommand);
    }
    return EventHandlersVoid.GetItem(eventName);
}


template <class __classType, class __argumentType>
inline mtsCommandWriteBase * mtsInterfaceRequired::AddEventHandlerWrite(void (__classType::*method)(const __argumentType &),
                                                                        __classType * classInstantiation,
                                                                        const std::string & eventName,
                                                                        mtsEventQueuingPolicy queuingPolicy)
{
    bool queued = this->UseQueueBasedOnInterfacePolicy(queuingPolicy, "AddEventHandlerWrite", eventName);
    mtsCommandWriteBase * actualCommand =
        new mtsCommandWrite<__classType, __argumentType>(method, classInstantiation, eventName, __argumentType());
    if (queued) {
        if (MailBox)
            EventHandlersWrite.AddItem(eventName,  new mtsCommandQueuedWrite<__argumentType>(MailBox, actualCommand, DEFAULT_EVENT_QUEUE_LEN));
        else
            CMN_LOG_CLASS_INIT_ERROR << "No mailbox for queued event handler write \"" << eventName << "\"" << std::endl;
    } else {
        EventHandlersWrite.AddItem(eventName, actualCommand);
    }
    return EventHandlersWrite.GetItem(eventName);
}


template <class __classType>
inline mtsCommandWriteBase * mtsInterfaceRequired::AddEventHandlerWriteGeneric(void (__classType::*method)(const mtsGenericObject &),
                                                                               __classType * classInstantiation,
                                                                               const std::string & eventName,
                                                                               mtsEventQueuingPolicy queuingPolicy)
{
    bool queued = this->UseQueueBasedOnInterfacePolicy(queuingPolicy, "AddEventHandlerWriteGeneric", eventName);
    mtsCommandWriteBase * actualCommand =
        new mtsCommandWriteGeneric<__classType>(method, classInstantiation, eventName, 0);
    if (queued) {
        if (MailBox) {
            EventHandlersWrite.AddItem(eventName,  new mtsCommandQueuedWriteGeneric(MailBox, actualCommand, DEFAULT_EVENT_QUEUE_LEN));
        } else {
            CMN_LOG_CLASS_INIT_ERROR << "No mailbox for queued event handler write generic \"" << eventName << "\"" << std::endl;
        }
    } else {
        EventHandlersWrite.AddItem(eventName, actualCommand);
    }
    return EventHandlersWrite.GetItem(eventName);
}
#endif  // !SWIG


/*! Stream out operator. */
inline std::ostream & operator << (std::ostream & output,
                                   const mtsInterfaceRequired::FunctionInfo & functionInfo) {
    functionInfo.ToStream(output);
    return output;
}

CMN_DECLARE_SERVICES_INSTANTIATION(mtsInterfaceRequired)


#endif // _mtsInterfaceRequired_h

